package com.was.inventory.controller;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.was.inventory.Repositories.*;
import com.was.inventory.model.*;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.hibernate.validator.constraints.NotBlank;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.io.IOException;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

/**
 * @author Waseem ud din
 * @version 0.1
 */
@Controller // This means that this class is a Controller
@RequestMapping(path = "/inventory") // This means URL's start with /demo (after Application path)
public class RequestController {

    private static final Logger logger = LogManager.getLogger(RequestController.class);

    private InformationRepository informationRepository;
    private CustomerRepository customerRepository;
    private PaymentRepository paymentRepository;
    private PaymentMethodRepository paymentMethodRepository;
    private SupplierRepository supplierRepository;
    private ItemRepository itemRepository;
    private SaleRepository saleRepository;
    private PurchaseRepository purchaseRepository;
    private OrderRepository orderRepository;
    private CategoryRepository categoryRepository;
    private ObjectMapper mapper;

    @Autowired // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private void RequestController(InformationRepository informationRepository,
                                   CustomerRepository customerRepository,
                                   SupplierRepository supplierRepository,
                                   PaymentRepository paymentRepository,
                                   PaymentMethodRepository paymentMethodRepository,
                                   SaleRepository saleRepository,
                                   ItemRepository itemRepository,
                                   PurchaseRepository purchaseRepository,
                                   OrderRepository orderRepository,
                                   CategoryRepository categoryRepository,

                                   ObjectMapper mapper) {

        this.informationRepository = informationRepository;
        this.customerRepository = customerRepository;
        this.supplierRepository = supplierRepository;
        this.paymentMethodRepository = paymentMethodRepository;
        this.paymentRepository = paymentRepository;
        this.orderRepository = orderRepository;
        this.saleRepository = saleRepository;
        this.itemRepository = itemRepository;
        this.purchaseRepository = purchaseRepository;
        this.categoryRepository = categoryRepository;
        this.mapper = mapper;
    }

    @RequestMapping(value = "/add/{type}", method = RequestMethod.POST, consumes = "application/json")
    public @ResponseBody
    ResponseEntity<JsonNode> addData(@NotBlank @RequestBody String requestBody,
                                     @PathVariable String type) {
//                                     @RequestParam(value = "payment", required = false) String payment) {

        logger.debug("Request for the inserting the data.");
        ObjectNode responseBody = mapper.createObjectNode();

        DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
        Map<String, Object> requestMap = new HashMap<String, Object>();
        logger.debug("Checking the condition of the type.");
        switch (type) {
            case "customer": {
                logger.debug("The condition for insertion of customer");
                logger.debug("Creating the reference of the Information (Customer) class.");
                Information information = null;
                try {
                    logger.info("Writing the value into the object of the information (Customer) using the request.");
                    information = mapper.readValue(requestBody, Information.class);
                } catch (IOException e) {

                    logger.error("Error while writing the information (Customer) data into its object", e);
                }

                try {
                    logger.info("Inserting the record into the database via customer");
                    customerRepository.save(new Customer(information));
                } catch (DataIntegrityViolationException e) {
                    logger.error("Error while inserting the information (Customer) data into its database table.", e);
                    return ResponseEntity.status(HttpStatus.CONFLICT).body(responseBody.put("error", e.getCause().toString()));
                }

                break;
            }
            case "supplier": {
                logger.debug("The condition for insertion of Supplier");
                logger.debug("Creating the reference of the Information (Supplier) class.");
                Information information = null;
                try {
                    logger.info("Writing the value into the object of the information (Supplier) using the request.");
                    information = mapper.readValue(requestBody, Information.class);
                } catch (IOException e) {
                    logger.error("Error while writing the information (Supplier) data into its object", e);
                }

                try {

                    logger.info("Inserting the record into the database via supplier");
                    supplierRepository.save(new Supplier(information));
                } catch (DataIntegrityViolationException e) {
                    logger.error("Error while inserting the information (Supplier) data into its database table.", e);
                    return ResponseEntity.status(HttpStatus.CONFLICT).body(responseBody.put("error", e.getCause().toString()));
                }

                break;

            }
            case "payment": {

                logger.debug("The condition for the insertion of the payment.");
                try {
                    logger.debug("Populating the request Map with the request to identify the type of .");
                    requestMap = mapper.readValue(requestBody, Map.class);
                } catch (IOException e) {
                    e.printStackTrace();
                }


                logger.debug("Identifying the key for the payment is it for customer or supplier.");
                Payment payment = null;
                if (requestMap.containsKey("customerId")) {
                    logger.debug("The request for the adding payment of the customer has been received.");
                    System.out.println(requestMap.get("customerId"));
                    Customer customer = null;
                    try {
                        customer = customerRepository.findById(((Integer) requestMap.get("customerId")));
                    } catch (ClassCastException e) {
                        System.out.print("eXCEPTION IN THE Map:" + requestMap);
                    }

                    PaymentMethod paymentMethod = paymentMethodRepository.getById((Integer) requestMap.get("methodId"));
                    try {
                        System.out.println("Customer: " + customer);
                        System.out.println("PaymentMethod: "+ paymentMethod.getName() );
                        System.out.println("Due Date: "+ requestMap.get("dueDate").toString());
                        System.out.println("paid: "+new Long((int)requestMap.get("paid")) );
                        System.out.println("payable: "+ new Long((int) requestMap.get("payable")));
                        System.out.println( "date" + dateFormat.parse(requestMap.get("date").toString()) );

                        payment = new Payment(dateFormat.parse(requestMap.get("dueDate").toString()), new Long((int)requestMap.get("paid")), new Long((int) requestMap.get("payable")), dateFormat.parse(requestMap.get("date").toString()), customer, paymentMethod);
                    } catch (ParseException e) {
                        e.printStackTrace();
                    } catch (NullPointerException e){
                        e.printStackTrace();
                        System.out.println(e.getCause());
                    }


                } else if (requestMap.containsKey("supplierId")) {

                    logger.debug("The request for the adding payment of the supplier has been received.");
                    Supplier supplier = supplierRepository.getById((Integer) requestMap.get("supplierId"));

                    PaymentMethod paymentMethod = paymentMethodRepository.getById((Integer) requestMap.get("methodId"));
                    try {
                        payment = new Payment(dateFormat.parse(requestMap.get("dueDate").toString()), new Long((int)requestMap.get("paid")), new Long((int)requestMap.get("payable")), dateFormat.parse(requestMap.get("date").toString()), supplier, paymentMethod);
                    } catch (ParseException e) {
                        e.printStackTrace();
                    }

                }

                paymentRepository.save(payment);

                break;
            }

            case "paymentMethod":{

                logger.debug("The condition for insertion of paymentMethod");
                logger.debug("Creating the reference of the paymentMethod class.");
                PaymentMethod paymentMethod = null;
                try {
                    logger.info("Writing the value into the object of the paymentMethod using the request.");
                    paymentMethod = mapper.readValue(requestBody, PaymentMethod.class);
                } catch (IOException e) {

                    logger.error("Error while writing the paymentMethod data into its object", e);
                }

                try {
                    logger.info("Inserting the record into the table of PaymentMethod");
                    paymentMethodRepository.save(paymentMethod);
                } catch (DataIntegrityViolationException e) {
                    logger.error("Error while inserting the PaymentMethod data into its database table.", e);
                    return ResponseEntity.status(HttpStatus.CONFLICT).body(responseBody.put("error", e.getCause().toString()));
                }
                break;
            }

        }
        return ResponseEntity.status(HttpStatus.OK).

                body(responseBody.put("success", "Inserted"));
    }

    @RequestMapping(value = "/get/{type}", method = RequestMethod.GET, produces = "application/json")
    public @ResponseBody
    ResponseEntity<JsonNode> getData(@PathVariable String type) {

        ObjectNode responseBody = new ObjectMapper().createObjectNode();
        logger.debug("Request received to get the data.");
        logger.debug("Checking the condition of the type.");
        switch (type) {
            case "customer": {
                logger.debug("The condition for getting the customers.");
                System.out.println(customerRepository.findByInformation_Name("waseem").get(0).getId());
                return ResponseEntity.status(HttpStatus.OK).body(mapper.valueToTree(customerRepository.getAllByInformationNotNull()));
            }
            case "supplier": {
                logger.debug("The condition for getting of Supplier");
                return ResponseEntity.status(HttpStatus.OK).body(mapper.valueToTree(supplierRepository.getAllByInformationNotNull()));

            }
//            case "payment":{
//
//                Payment payment = new Payment();
//                Customer customer = new Customer();
//                customer.setId(Integer.parseInt(requestMap.get("customer_id")));
//                Set paymentSet = new HashSet<Payment>();
//
//                break;
//            }

        }
        return ResponseEntity.status(HttpStatus.OK).body(responseBody.put("error", "Inserted"));

    }
}
